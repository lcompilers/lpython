-- This is an Abstract Syntax Description Lanuguage (ASDL) that describes the
-- Fortran's Abstract Syntax Tree (AST). See [1] for a short background
-- information and motivation and see the paper [2] for a detailed motivation,
-- explanation and specification of the language. See [3] for further examples
-- of ASDL usage in a real compiler.
--
-- [1] https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers/
-- [2] Wang, D. C., Appel, A. W., Korn, J. L., & Serra, C. S. (1997). The Zephyr Abstract Syntax Description Language. USENIX Conference on Domain-Specific Languages, (October), 213â€“228.
-- [3] https://arxiv.org/abs/cs/9810013
--
-- ASDL's builtin types are:
--   * identifier
--   * int (signed integers of infinite precision)
--   * string
-- We extend these by:
--   * node (any ASDL node)
--   * bool
--
-- Specific tools may choose to produce language interfaces that represent
-- these types and the ASDL tree in a language specific way (e.g. use finite
-- precision integers and signal an error otherwise).
--
-- At the AST level we strictly only represent local syntax (no semantics). That
-- way each syntax construct is parsed locally, no need to do any non-local
-- lookups to figure out what AST node to construct. That is the job of the AST
-- to ASR conversion to do non-local lookups to figure out what is what (i.e.,
-- disambiguate) and report any errors.

module AST {

unit
    = TranslationUnit(node* items)

mod
    = Module(identifier name, unit_decl1* use, unit_decl2* decl,
        program_unit* contains)
    | Submodule(identifier id,identifier name, unit_decl1* use, unit_decl2* decl,
        program_unit* contains)
    | Program(identifier name, unit_decl1* use, unit_decl2* decl,
        stmt* body, program_unit* contains)

program_unit
    = Subroutine(identifier name, arg* args, bind? bind, unit_decl1* use,
            import_statement* import,
            unit_decl2* decl, stmt* body, program_unit* contains)
    | Procedure(identifier name, arg* args, unit_decl1* use, unit_decl2* decl,
            stmt* body, program_unit* contains)
    | Function(identifier name, arg* args, decl_attribute* attributes,
            expr? return_var, bind? bind, unit_decl1* use,
            import_statement* import,
            unit_decl2* decl, stmt* body, program_unit* contains)

unit_decl1
    = Use(identifier module, use_symbol* symbols)

unit_decl2
    = Declaration(decl_attribute? vartype, decl_attribute* attributes,
        var_sym* syms)
    | Interface(interface_header header, interface_item* items)
    | DerivedType(identifier name, unit_decl2* items)
    | Enum()

interface_header
    = InterfaceHeader1()
    | InterfaceHeader2(identifier name)
    | InterfaceHeader3()
    | InterfaceHeader4()
    | InterfaceHeader5()

interface_item
    = InterfaceProc(program_unit proc)
    | InterfaceModuleProcedure(identifier* names)

import_statement
    = Import(identifier* symbols, import_modifier mod)

import_modifier
    = ImportDefault
    | ImportOnly
    | ImportNone
    | ImportAll

stmt
-- Single-line statements (each has a `label`):
    = Allocate(int label, fnarg* args, keyword* keywords)
    | Assignment(int label, expr target, expr value)
    | Associate(int label, expr target, expr value)
    | Backspace(int label, expr* args, keyword* kwargs)
    | Close(int label, expr* args, keyword* kwargs)
    | Continue(int label)
    | Cycle(int label)
    | Deallocate(int label, fnarg* args)
    | ErrorStop(int label, expr? code)
    | Exit(int label)
    | Format(int label, string fmt)
    | GoTo(int label, int goto_label)
    | Inquire(int label, expr* args, keyword* kwargs, expr* values)
    | Nullify(int label, expr* args, keyword* kwargs)
    | Open(int label, expr* args, keyword* kwargs)
    | Return(int label)
    | Print(int label, string? fmt, expr* values)
    | Read(int label, argstar* args, kw_argstar* kwargs, expr* values)
    | Rewind(int label, expr* args, keyword* kwargs)
    | Stop(int label, expr? code)
    | SubroutineCall(int label, identifier name, fnarg* args, keyword* keywords)
    | Write(int label, argstar* args, kw_argstar* kwargs, expr* values)

-- Multi-line statements (each has a `label` and `stmt_name`):
    | If(int label, identifier? stmt_name, expr test, stmt* body, stmt* orelse)
    | Where(int label, identifier? stmt_name, expr test, stmt* body,
            stmt* orelse)
    | DoLoop(int label, identifier? stmt_name, identifier? var, expr? start,
            expr? end, expr? increment, stmt* body)
    | DoConcurrentLoop(int label, identifier? stmt_name,
            concurrent_control *control, expr? mask,
            concurrent_locality* locality, stmt* body)
    | Select(int label, identifier? stmt_name, expr test, case_stmt* body,
            stmt* default)
    | WhileLoop(int label, identifier? stmt_name, expr test, stmt* body)

expr
    = BoolOp(expr left, boolop op, expr right)
    | BinOp(expr left, operator op, expr right)
    | StrOp(expr left, stroperator op, expr right)
    | UnaryOp(unaryop op, expr operand)
    | Compare(expr left, cmpop op, expr right)
    | FuncCallOrArray(identifier func, struct_member* member,
        fnarg* args, keyword* keywords)
    | ArrayInitializer(expr* args)
    | ImpliedDoLoop(expr* values, identifier var, expr start, expr end,
        expr? increment)
    | Num(int n)
    | Real(string n)
    | Complex(expr re, expr im)
    | Str(string s)
    | Name(identifier id, struct_member* member)
    | Logical(bool value)

boolop = And | Or | Eqv | NEqv

operator = Add | Sub | Mul | Div | Pow

stroperator = Concat

unaryop = Invert | Not | UAdd | USub

cmpop = Eq | NotEq | Lt | LtE | Gt | GtE

decl_attribute
    = AttrBind(identifier name)
    | AttrDimension(dimension* dim)
    | AttrExtends(identifier name)
    | AttrIntent(attr_intent intent)
    | AttrNamelist(identifier name)
    | SimpleAttribute(simple_attribute attr)
    | AttrType(decl_type type, kind_item* kind, identifier? name)

simple_attribute
    = AttrAbstract
    | AttrAllocatable
    | AttrContiguous
    | AttrElemental
    | AttrEnumerator
    | AttrImpure
    | AttrModule
    | AttrNoPass
    | AttrOptional
    | AttrParameter
    | AttrPointer
    | AttrPrivate
    | AttrProtected
    | AttrPublic
    | AttrPure
    | AttrRecursive
    | AttrSave
    | AttrTarget
    | AttrValue

attr_intent = In | Out | InOut

decl_type
    = TypeClass
    | TypeCharacter
    | TypeComplex
    | TypeDoublePrecision
    | TypeInteger
    | TypeLogical
    | TypeProcedure
    | TypeReal
    | TypeType

var_sym = (identifier name, dimension* dim, expr? initializer)

kind_item = (identifier? id, expr? value, kind_item_type type)

kind_item_type = Star | Colon | Value

dimension = (expr? start, expr? end, dimension_type end_star)
dimension_type = DimensionExpr | DimensionStar

-- Encoding of an array dimension declaration:
--           start      end     end_star
-- Declaration:
-- X(n)       1          n       Expr   # Note: X(n) is equivalent to X(1:n)
-- X(:)       ()         ()      Expr
-- X(a:)      a          ()      Expr
-- X(:b)      ()         b       Expr
-- X(a:b)     a          b       Expr
-- X(*)       ()         ()      Star
-- X(a:*)     a          ()      Star


-- Null for `expr` means it's a star
kw_argstar = (identifier arg, expr? value)
argstar = (expr? value)

-- The identifier is wrapped up in a product type so that location information
-- is included:
arg = (identifier arg)


-- Encoding of array elements and sections in fnarg:
--           start      end     step
-- element:
-- X(i)       ()         i       ()
-- section:
-- X(:)       ()         ()      1
-- X(a:)      a          ()      1
-- X(:b)      ()         b       1
-- X(a:b)     a          b       1
-- X(::c)     ()         ()      c
-- X(a::c)    a          ()      c
-- X(:b:c)    ()         b       c
-- X(a:b:c)   a          b       c
--
fnarg = (expr? start, expr? end, expr? step)

keyword = (identifier arg, expr value)

struct_member = (identifier name, fnarg* args)

bind = Bind(expr* args, keyword* kwargs)

array_index = ArrayIndex(expr? left, expr? right, expr? step)

case_stmt = CaseStmt(expr* test, stmt* body) | CaseStmt_Range(expr? start, expr? end, stmt* body)

use_symbol = UseSymbol(identifier sym, identifier? rename)

concurrent_control = ConcurrentControl(identifier? var, expr? start, expr? end, expr? increment)

concurrent_locality
    = ConcurrentLocal(identifier *vars)
    | ConcurrentLocalInit(identifier *vars)
    | ConcurrentShared(identifier *vars)
    | ConcurrentDefault()
    | ConcurrentReduce(reduce_op op, identifier *vars)

reduce_op = ReduceAdd | ReduceMul | ReduceMIN | ReduceMAX

}
